<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Cook Paddy — Technical Overview</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: #fff; color: #000; line-height: 1.6; padding: 40px; max-width: 900px; margin: 0 auto; }
    h1 { font-size: 2rem; margin-bottom: 10px; }
    h2 { font-size: 1.5rem; margin: 40px 0 20px; border-bottom: 1px solid #000; padding-bottom: 10px; }
    h3 { font-size: 1.2rem; margin: 30px 0 15px; }
    p { margin: 15px 0; }
    blockquote { border-left: 3px solid #000; padding-left: 15px; margin: 20px 0; font-style: italic; }
    table { width: 100%; border-collapse: collapse; margin: 20px 0; }
    th, td { border: 1px solid #000; padding: 10px; text-align: left; }
    th { font-weight: bold; }
    pre { background: #f5f5f5; border: 1px solid #000; padding: 15px; overflow-x: auto; margin: 15px 0; font-family: 'Courier New', monospace; font-size: 0.9rem; }
    code { font-family: 'Courier New', monospace; background: #f5f5f5; padding: 2px 5px; }
    ul { margin: 15px 0; padding-left: 25px; }
    li { margin: 8px 0; }
    hr { border: none; border-top: 1px solid #000; margin: 30px 0; }
    .footer { text-align: center; margin-top: 40px; font-style: italic; }
  </style>
</head>
<body>

<h1>Cook Paddy — Technical Overview</h1>

<blockquote>
  <strong>A cooking accountability system that takes recipes from wherever you find them, keeps them organized, and pushes you to actually cook them.</strong>
</blockquote>

<hr>

<h2>Tech Stack</h2>

<table>
  <tr><th>Layer</th><th>Technology</th></tr>
  <tr><td><strong>Mobile</strong></td><td>Flutter 3.9+, Riverpod, GoRouter</td></tr>
  <tr><td><strong>Backend</strong></td><td>Node.js 22, TypeScript, Express</td></tr>
  <tr><td><strong>AI/ML</strong></td><td>Google Gemini 2.5 Flash, Cloud Vision API, OpenAI Whisper</td></tr>
  <tr><td><strong>Vector Search</strong></td><td>Pinecone (text-embedding-3-small, 512 dims)</td></tr>
  <tr><td><strong>Database</strong></td><td>Firebase Firestore</td></tr>
  <tr><td><strong>Infrastructure</strong></td><td>Firebase Functions, Cloud Run, Cloud Tasks</td></tr>
  <tr><td><strong>Payments</strong></td><td>RevenueCat</td></tr>
</table>

<hr>

<h2>Architecture</h2>

<pre>
┌──────────────────────────────────────────────────────────────────┐
│                     Flutter Mobile App                            │
│         (Riverpod State Management + GoRouter Navigation)         │
│                                                                    │
│  Video Share → Device downloads video → Uploads to server         │
└──────────────────────────────────────────────────────────────────┘
                                │
                    ┌───────────┴───────────┐
                    ▼                       ▼
         ┌──────────────────┐    ┌──────────────────┐
         │ Firebase Auth    │    │ Cloud Run API    │
         │ Firestore        │    │ (Express.js)     │
         │ Cloud Storage    │    └────────┬─────────┘
         └──────────────────┘             │
                                          ▼
                              ┌──────────────────────┐
                              │   LangGraph Agent    │
                              │  (Recipe Extraction) │
                              └──────────┬───────────┘
                    ┌────────────────────┼────────────────────┐
                    ▼                    ▼                    ▼
            ┌─────────────┐      ┌─────────────┐      ┌─────────────┐
            │ Vision API  │      │ Gemini 2.5  │      │  Pinecone   │
            │ (OCR)       │      │ (Parsing)   │      │ (Search)    │
            └─────────────┘      └─────────────┘      └─────────────┘
</pre>

<hr>

<h3>Subscription Flow</h3>
<pre>
User → RevenueCat SDK (Flutter) → App Store → RevenueCat Dashboard
                                                      │
                                          POST /subscriptions/webhook
                                                      │
                                                      ▼
                                              Firestore (user doc)
                                          activeSubscription updated
</pre>

<hr>

<h2>Core Features (Summary)</h2>

<table>
  <tr><th>Feature</th><th>Technical Implementation</th></tr>
  <tr><td><strong>Recipe Import</strong> (URL, video, PDF, camera, manual)</td><td>LangGraph agent routes to appropriate tool → Gemini 2.5 Flash extracts structured data. Videos use device-first download then server-side multimodal processing.</td></tr>
  <tr><td><strong>Search</strong> (natural language, voice, ingredient scan)</td><td>Pinecone vector search (text-embedding-3-small, 512 dims) with metadata filters. Whisper for voice transcription. Vision API for ingredient scanning.</td></tr>
  <tr><td><strong>Cookbook Organization</strong></td><td>User-created collections in Firestore</td></tr>
  <tr><td><strong>Tasks &amp; Reminders</strong></td><td>Server-side scheduler (5 min interval) → FCM push notifications. Tasks link to recipes and grocery lists.</td></tr>
  <tr><td><strong>iOS Widgets</strong> (small, medium, large, lock screen)</td><td>WidgetKit with background refresh and deep linking</td></tr>
  <tr><td><strong>Story Mode</strong></td><td>Instagram Stories-style step-by-step cooking interface with confetti on completion</td></tr>
  <tr><td><strong>Export</strong></td><td>Generate and share recipe as PDF</td></tr>
  <tr><td><strong>Health Benefit Alerts</strong></td><td>On recipe save → enrollment with spread scheduling (0-30 min) → scheduler (every 10 min) → Gemini analyzes nutrition vs user health goals → if ≥70% confidence match → auto-create cooking task + FCM push notification. Rate limited to 3 alerts/user/day.</td></tr>
</table>

<p><strong>AI Pipeline:</strong></p>
<pre>Input → LangGraph Router → [PDF|Image|Video|URL|Text] → Gemini 2.5 Flash → Structured Recipe → Pinecone Embedding</pre>

<p><strong>Health Benefit Alerts Pipeline:</strong></p>
<pre>Recipe Created → Enrollment (0-30 min spread) → Scheduler (every 10 min) → Gemini AI Analysis
  → Match (≥70% confidence) → Create Task + Send Push Notification
  → No Match → Mark as no_match</pre>

<hr>

<h2>Data Models</h2>

<h3>Recipe</h3>
<pre>{
  id, name, userId,
  ingredients: Record&lt;string, { name, quantity, unit, category }&gt;,
  instructions: Record&lt;string, { text, timeType, timeInSeconds }&gt;,
  categories: ["dinner", "italian"],
  difficulty: "easy" | "medium" | "hard",
  prepTimeInSeconds, cookTimeInSeconds,
  images: Record&lt;string, { url, source }&gt;
}</pre>

<h3>Task (with Reminders)</h3>
<pre>{
  taskId, title, createdBy,
  label: "shopping" | "cook",
  reminder: { remindAt: timestamp },
  linkedRecipes: { recipes: string[], details: {...} }
}</pre>

<h3>Health Alert Enrollment</h3>
<pre>{
  id, userId, recipeId, recipeName,
  recipeCategories: string[],
  scheduledAt: number,
  status: "pending" | "processed" | "no_match" | "skipped" | "failed",
  createdAt: number,
  processedAt?: number,
  matchResult?: {
    isMatch: boolean,
    confidence: number,        // 0.0 - 1.0, threshold ≥ 0.7
    matchedBenefits: string[], // e.g. ["high_protein", "low_carb"]
    reasoning: string,
    suggestedTaskTitle?: string
  }
}</pre>

<hr>

<h2>Mobile App</h2>

<p><strong>State Management:</strong> Riverpod 3.x with <code>DataResult&lt;T&gt;</code> pattern for loading states</p>

<p><strong>Navigation:</strong> GoRouter with <code>StatefulShellRoute</code> for bottom navigation</p>

<p><strong>Key Features:</strong></p>
<ul>
  <li>Universal recipe import — URL, video share, PDF cookbook, camera scan, manual entry</li>
  <li>AI-powered search with voice input and camera ingredient scanning</li>
  <li>Cookbook creation and recipe organization</li>
  <li>Tasks and reminders linked to recipes and grocery lists</li>
  <li>Instagram Stories-style step-by-step cooking interface</li>
  <li>iOS Share Extension for importing directly from other apps</li>
  <li>Home Screen Widgets (small, medium, large) and Lock Screen Widgets via WidgetKit</li>
  <li>Recipe export as shareable PDF</li>
  <li>Health benefit alerts — AI matches saved recipes to user health goals with auto-task creation</li>
</ul>

<hr>

<h2>RevenueCat Implementation</h2>

<h3>Subscription Plans</h3>

<table>
  <tr><th>Plan</th><th>Price</th><th>Entitlement</th></tr>
  <tr><td><strong>Weekly</strong></td><td>$2.99/week</td><td>Pro</td></tr>
  <tr><td><strong>Bi-Monthly</strong></td><td>$20/2 months</td><td>Pro</td></tr>
  <tr><td><strong>Annual</strong></td><td>$119/year</td><td>Pro</td></tr>
</table>

<p><strong>Geo-Targeted Offerings:</strong> Using RevenueCat's Targeting feature, offerings are customized by region. For example, Nigerian users see only weekly and bi-monthly plans — no annual option — to better match local purchasing behavior and affordability.</p>

<p><strong>Pro unlocks:</strong> Cookbook PDF imports, video extraction from social media, camera OCR scanning, voice search, health benefit alerts. Free users can add recipes manually, organize cookbooks, use story mode, and set reminders.</p>

<h3>Mobile SDK Integration (Flutter)</h3>

<pre>// Fetch offerings (OfferingNotifier)
void fetchOfferings() async {
  final Offerings offerings = await Purchases.getOfferings();
  state = state.copyWith(data: offerings.current);
}

// Purchase flow (CurrentPackageNotifier)
Future&lt;void&gt; purchase(bool restore, Function() onCompleted) async {
  if (restore) {
    final info = await Purchases.restorePurchases();
    if (info.activeSubscriptions.isEmpty) {
      showToast("No active purchases found");
    }
    return;
  }

  final purchaseParams = PurchaseParams.package(selectedPackage);
  await Purchases.purchase(purchaseParams);
  onCompleted();
}</pre>

<h3>Entitlement Check</h3>

<pre>// Check if user has active Pro subscription
Package? get currentActiveUserPackage {
  return state.data?.availablePackages.firstWhere(
    (package) =&gt;
        currentUser?.activeSubscription?.productId == 
            package.storeProduct.identifier &amp;&amp;
        currentUser?.activeSubscription?.status == 'active',
  );
}

bool get isProUser =&gt; currentActiveUserPackage != null;</pre>

<h3>Server-Side Webhook</h3>

<pre>App Store → RevenueCat → POST /subscriptions/webhook → Firestore</pre>

<p><strong>Webhook Events Handled:</strong></p>
<pre>const PURCHASE_EVENTS = [
  "INITIAL_PURCHASE", 
  "RENEWAL", 
  "SUBSCRIPTION_EXTENDED", 
  "PRODUCT_CHANGE"
];

const CANCEL_EVENTS = [
  "UNSUBSCRIBE", 
  "EXPIRATION", 
  "BILLING_ERROR", 
  "BILLING_ISSUE"
];</pre>

<p><strong>Purchase Event Handler:</strong></p>
<pre>async handlePurchaseEvent(event, user) {
  const subscription = {
    id: event.transaction_id,
    productId: event.new_product_id ?? event.product_id,
    entitlements: event.entitlement_ids || [],
    promoCode: event.offer_code ?? null,
    durations: {
      startAt: event.purchased_at_ms,
      endAt: event.expiration_at_ms,
    },
    status: "active",
  };

  await userService.updateSubscription(user.id, subscription);
  
  if (event.offer_code) {
    await this.claimPromoCode(event.offer_code);
  }
  
  await this.createTransaction(event, user);
}</pre>

<h3>Subscription Data Model</h3>

<pre>// Stored in Firestore users/{uid}.activeSubscription
activeSubscription: {
  id: string,                    // transaction_id
  productId: string,             // e.g. "Cook Paddy_pro_weekly"
  entitlements: string[],        // ["pro"]
  promoCode: string | null,      // offer code if used
  status: "active" | "cancelled" | "expired",
  durations: { 
    startAt: number,             // purchased_at_ms
    endAt: number                // expiration_at_ms
  },
  updatedAt: number
}</pre>

<h3>Transaction Records</h3>

<p>Each purchase creates a transaction record for analytics:</p>
<pre>// Stored in Firestore transactions/{id}
{
  id, transactionId,
  amount: { price, currency, type: "charge" },
  createdBy: { uid, name, email },
  meta: { subscriptionId, productId, durations }
}</pre>

<hr>

<h2>Deployment</h2>

<table>
  <tr><th>Service</th><th>Region</th><th>Purpose</th></tr>
  <tr><td>Cloud Run</td><td>europe-west3</td><td>API + AI agents</td></tr>
  <tr><td>Firebase Functions</td><td>europe-west3</td><td>Triggers + schedulers</td></tr>
  <tr><td>Cloud Tasks</td><td>europe-west3</td><td>Async recipe extraction</td></tr>
  <tr><td>Pinecone</td><td>us-east-1</td><td>Vector search</td></tr>
</table>

<hr>

<h2>Security</h2>

<ul>
  <li>Firebase Auth with Google/Apple Sign-In</li>
  <li>Owner-only access to recipes/cookbooks</li>
  <li>Rate limiting (100 req/15 min)</li>
  <li>Input validation on all endpoints</li>
</ul>

<hr>

<p class="footer"><em>Built with Flutter, Firebase, and Google AI</em></p>

</body>
</html>
